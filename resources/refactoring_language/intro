


Software ecosystems consist of software projects that are
developed and evolve together in a shared environment [13].
Research on such ecosystems only recently emerged within
software engineering [15]. It addresses, among other things,
the analysis of the characteristics and evolution of software
ecosystems, which some researchers consider to be a central
subject in this field of research [26]

Software ecosystems are environments that form as projects evolve in parallel,
becoming interconnected as contexts and dependencies span companies and communities [13]. 
Research on these systems has increased rapidly in the recent past [new], investigating
their characteristics and behaviour as they develop [14]. Understanding how software
ecosystems form and change is valuable from both a software as well as a business standpoint [15],
and is important for informing developers how technologies are used over time [26]. 
An understanding of software ecosystems can inform decisions on when to adopt frameworks and how long
to support them, as well as provide insight into how changes to software propagate throughout the community [wittern].




To that regard, some
software ecosystems have been scientifically assessed, including the Maven [23], Apache [2], Gentoo [4], Ruby [11], and
R [8] ecosystems. Nonetheless, a systematic literature study
from 2013 found that research regarding real-world software
ecosystems is lacking [14].

[n/a]


The study of characteristics and the evolution of software
ecosystems is an end in itself, allowing to understand how
certain technologies spread or why others fail. In addition,
this research can also inform the design of new ecosystems
and associated tooling, including technical as well as social
aspects [26]. Furthermore, as software projects are seldom
created in isolation, studying individual software projects
often requires studying the ecosystem around them [3].


Additionally, determining the characteristics of software ecosystems 
can help clarify why some frameworks flourish while others fail, and guide 
developers in the creation of new tools\cite{serebrenik}. Furthermore, 
because software projects are overwhelmingly a collaborative effort, a complete
understanding of a single project often requires knowledge of the ecosystem surrounding them[blnko].



The node package manager (npm) combines a set of open
source tools that developers use to describe their JavaScript
packages, and specifically Node.js packages. These tools include, for example, a command line interface to create and
maintain package.json files, which declare, among other
things, the name, description, version, and dependencies of
a package. npm furthermore features a registry that developers can use to publish their packages, making them available
for others to use. Packages within npm may depend on each
other, and software projects outside of npm, for example applications, may specify dependencies to packages hosted on
npm. 

npm provides a set of open source tools that allow developers to 
describe packages for Node.js, an asynchronous JavaScript runtime environment 
designed for network applications \footnote{https://nodejs.org/en/about/}.
The services provided by npm include a command line interface for maintaining 
package.json files, the primary method for describing package metadata such as the name,
description, version, and dependencies of a given package. npm also allows 
developers to publish their packages to a public registry, permitting anyone 
to download and use their software. Packages hosted on npm will often depend on other npm packages,
creating an elaborate JavaScript ecosystem of interdependence.

Since its creation in 2009, npm has grown rapidly to now
feature over 230, 000 packages (as of January 28th, 2016).
npm provides a complete set of various historic data points
on the packages in the ecosystem. This data thus not only
provides insights into the current state of the ecosystem, but
also into how the ecosystem evolved over time. The diversity
of available data points furthermore allows us to assess the
ecosystem from multiple perspectives and to compare these
perspectives. Understanding npm provides valuable insights
into the rapid growth JavaScript and Node.js experienced
within the last years. It also helps to understand how individual packages rose in popularity, prevailed, and sometimes
were eventually replaced or disregarded.


///// ecosystem evolution

Created in 2009, \code{npm} has grown
rapidly in popularity and scope over the last ten years, and 
as of the original paper showed no signs of slowing down \cite{Wittern:2016}.
We investigate the state of the \code{npm} ecosystem
since September 1\super{st} 2015, and look for any signs of deterioration in 
the health of the ecosystem. Periods of stagnating growth would suggest
that developer interest is waning, while steady activity would 
indicate that the ecosystem as a whole is healthy and will continue to
evolve. To search for these potential indicators in the \code{npm} package environment,
we investigate the number of packages created and updated over time, as well
as system-wide trends of dependencies within packages. In figure 1 
[INSERT DATA COMMENTARY HERE]. Figure 2 [MORE DATA COMMENTARY].



The npm package repository was created in 2009. Over the
last six years, the software repository has evolved rapidly
and currently hosts over 230, 000 packages. We investigate
the evolution of this ecosystem over this period and look for
signs of stagnation. Stagnation indicates that the community 
involvement has slowed down, while continued signs of
growth and activity indicates that there is increasing adoption 
and contributions by the developer community. To
characterize growth and activity, we look at the number of
new packages added to the repository over the observation
period, the number of packages that were updated, and the
dependencies among packages.

In Figure 1, we show the growth in number of packages
that are being added to npm every month, and the number of
packages that are being updated per month. Broadly speaking, 
we find that the developer community around Node.js
has been steadily increasing over the last 6 years, as evidenced 
by the increasing number of packages being created every month 
in the npm repository. In addition, the
community is also quite active in terms of maintaining the
packages hosted in the repository, as indicated by the twofold 
increase in the number of packages being updated every
month.


We then compare the growth in the total number of packages over 
time with the dependencies, i.e., relationships, between packages. 
The dependency measure per package is
the sum of number of its dependencies mentioned in dependencies 
and devDependencies fields in the package.json
file corresponding to each package. As shown in Figure 2,
not only is the npm ecosystem growing superlinearly in terms
of the number of packages and dependencies, the relationship 
among packages is also growing at a much higher rate,
indicating that the packages are depending more and more
on each other. We confirm our observation by plotting the
average number of dependencies per package (red line) in
the same figure. On average, a package in npm had approximately
 4-6 dependencies on other packages in late 2015,
compared to just one dependency in early 2011.

To further understand the dependency relationship between 
packages, we constructed a directed graph, where
packages form the vertices and directed edges between vertices
 represent the dependency between the two packages.
The out degree of a vertex indicates the number of dependencies
 of the package represented by the vertex, while the
in degree represents the number of packages that depend on
the given package.
Figure 3 shows the distribution of the out degrees across
all packages over time. The number of packages having one
or more dependencies has increased from 23.4% in January
2011 to 81.3% by end of August 2015. Specifically, there has
been a steady increase in the number of packages with 6 or
more dependencies, starting with 0% in January 2011 and
reaching 32.5% by end of August 2015.

To better visualize the status of inter-package dependencies, we constructed
a directed dependency graph using dependants as out-degrees and
dependencies as in-degrees. Based on this dependency graph, Figure 3
displays the percentage of packages with various amounts of dependencies. 
[MIGHT NEED TO CHANGE BASED ON DATA: While the average number of dependencies 
of packages continues to increase, the percentage of packages with zero 
to three dependencies has actually increased since the end of the original paper's
reporting period \cite{Wittern:2016}. This suggests some changes to developer 
behaviour, either deliberately as programmers seek to avoid the perils of 
complicated dependency trees \cite{Kikas}, or as a natural result of the ever-changing
ways in which JavaScript is used for project development.



Given the increasing number of external dependencies per
package, we tried to understand whether such dependencies 
were spread equally across all packages or if they were
confined to just a limited set of packages. To answer this
question, we look at Figure 4, showing the distribution of
in degrees across all packages. At the end of August 2015,
72.5% of packages had no incoming dependency, i.e., they
had no dependent packages, while only 4.9% of packages had
6 or more dependants, up from 1.1% in January 2011. Such
uneven distribution of package dependencies has been previously 
observed in other software ecosystems as well [18].

In addition to the number of external dependencies per package, 
we investigate how packages support dependants. The original paper 
discovered that the majority of in degrees are concentrated among a core 
minority of packages, with the majority of packages having no dependants,
a discovery that has also been observed in other software ecosystems such
as Linux and MySQL \cite{Myers:2003}. In our updated data, we discover 
that not only have these aspects held true, but the concentration of 
dependencies has actually increased proportionately, with [NUMBER]% of packages
having zero dependants, up from [NUMBER]% in 2015. Meanwhile, only %[NUM] of packages
had 6 or more dependants, down from %[NUM] as of September 1\textsuperscript{st} 2015.






In Section 4, we investigate the ranking of packages within
and outside the ecosystem to shed light on the dynamics of
package popularity in the npm ecosystem.
Takeaways. We find that the npm ecosystem continues to
grow in terms of the number of packages it hosts. At the
same time, the number of packages being updated monthly
has also grown two-fold, indicating that the developer 
community remains quite active in terms of maintaining their
packages. Looking at the relationships between packages,
we find there is an increasing amount of dependency across
packages, with 81.3% of them depending on at least one
package and 32.5% of them depending on 6 or more packages.
 However, the proportion of packages that are being
depended upon is only 27.5% of overall packages in npm, 
indicating that package dependencies exhibit a power law 
distribution, as has been observed by prior research on 
software related artifacts and ecosystems [12, 18].

[todo ^^^^]

In section \ref{}, we revisit the popularity measures
investigated in the original paper \cite{Wittern:2016} to discover
changes in the relationships between package rankings
both inside and outside of the \code{npm} ecosystem,
gaining insight into the dynamics of \code{npm} package popularity.

\textbf{Takeaways.} We find that while the \code{npm} ecosystem
continues to grow, the rate of growth is no longer superlinear, 
a possible sign of the ecosystem beginning to reach some form of maturity.
In the relationships between packages, we find that though the average number
of dependencies continues to grow, there has been a recent decline in the
rate of this growth. Accordingly, we have found that the number of packages with
zero dependencies has increased from 28.7% in September 2015 to [DATA REQUIRED]%
as of April 2019. The percentage of packages that are depended on has
also declined, albeit still exhibiting a power law relationship as observed
in prior software ecosystem research \cite{Witterm:2016}



RELATED WORK:


Empirical exploration of software ecosystems is important
to the field of software ecosystem research \cite{serebrenik}.
Related work can be 

Related research can be generally described as one of two types
of work: meta-analyses of the behaviour and importance
of software ecosystems, and empirical investigations into the
specifics of a particular ecosystem. Some topics 
for meta-analyses include ecosystem visualization \cite{Lungu},
ecosystem maturity \cite{Alves:2011}, quality metric aggregation \cite{Mordal:2013},
and literature reviews \cite{Manikas, manikas}. Specific ecosystem analysis include works such
paper and the original research by Wittern, Suter and Rajagopalan \cite{Wittern:2016} on \code{npm}.
Others have performed evaluations of specific ecosystems such as Raemaekers et al \cite{Raemaekers:2013},
who present a dataset with basic metrics, dependencies and changes within the popular 
Java-based Maven ecosystem. Another work investigates the
result of changing project interdependencies in Apache \cite{Bavota:2013}, 
and still others evaluate evolution over time in ecosystems such as
Gentoo \cite{Bloemen:2014}, Ruby, \cite{Kabbedijk:2011}, and R \cite{Plakidas:2017}.




Empirical analysis of software ecosystems is an important
aspect of software ecosystem research as a whole [26]. 
Correspondingly, related work focuses on specific aspects like
visualization [13], depicting ecosystem maturity [1], or how
to aggregate software quality metrics [17].
Some works empirically analyze software ecosystems that
evolve around a specific programming languages, as we did
for npm. Raemaekers et al. present a crawled dataset containing 
basic metrics, dependencies, and changes with some
aggregate statistics about Maven, a popular package manager
for Java [23]. Another work runs software to identify bugs in
source code of libraries shared in the same ecosystem [16]. In
contrast to these works, our study of the npm ecosystem focuses 
on the ecosystem evolution, popularity measures, and
package versioning. An analysis of the statistical computing 
project R [8] finds a super-linear growth in packages as
we report in Section 3. In addition, the study focuses on
characterizing contributions to user-contributed versus core
packages. We refrain from running a similar analysis as npm
does not differentiate packages explicitly in such a way, 
although we did identify different types of packages based on
our analysis of popularity measures (see Section 4.2). In [11],
the authors present results of a quantitative study of the
Ruby ecosystem. The paper presents a graph visualization
of the whole ecosystem as well as some descriptive statistics
and histograms about selected characteristics of packages,
including downloads and package size. In contrast to our
work, the dataset is much smaller, having only around 10K
gem nodes and 13.1K dependencies. Furthermore, the paper
does not go into the dynamics of the ecosystem, considering
instead a single point in time. We did not find any published
empirical analyses of the npm ecosystem.
Some works have studied the evolution of versions and corresponding 
change of software projects. For example, in a recent empirical 
study [5] regarding two ecosystems (including
npm) the authors find that developers struggle with changing 
versions as they might break dependent code. Similar
assessments on the effects of changes have been made regarding 
the Apache ecosystem [2] or the Maven ecosystem [24].
In contrast to these works, we assess versions in npm from a
black-box perspective: we do not assess how version changes
are reflected in the implementation of individual packages,
but focus on the occurrence of version numbers and how
they are adopted by application developers.
Finally, npm has occasionally been analyzed out of the context 
of peer-reviewed venues. npm packages pagerank provides a 
keyword-based search for packages, and presents the
results as recommendations based on their PageRank [21].
While we also consider the PageRank as a possible popularity 
measure, we have shown that this metric may not be
adequate for packages most useful to application developers
(Section 4.2). The project npm by numbers analyses a
snapshot of the npm ecosystem from September 2015 and
presents various statistics on it, including the distribution
of version numbers and releases of packages and the 
dependencies between packages [25]. In contrast to our work, npm
by numbers considers only a single point in time, whereas
we focus on the evolution of the ecosystem, and provides no
insight derived from client applications.






With the differences and changes in the relationships between
popularity measures explored, we can now examine \code{npm}
rankings in particular, as it is most representative of the 
importance of a package to the \code{npm} ecosystem as a whole.
To obtain \code{npm} ranks over time, we first begin with the
complete dependency graph as of April 2019. We then examine
the date references on the edges of the graph to produce \code{PageRanks}
for each and every package on a monthly basis for the period of October 2010
to April 2019. From the list of \code{PageRanks} in each month, we then
produce the relative rank for every package present in the \code{npm}
ecosystem at that time. 


Having established differences in the meaning of different
popularity measures, we now focus on one measure and assess
how package popularity evolves with regard to it over
time. The npm rank denotes how central a package is to
the npm ecosystem. To obtain npm ranks over time, we start
with the complete dependency graph as of September 1st
2015. Using the date annotations between all edges in the
graph, we then create a filtered version of that graph for
every week between September 1st 2010 and September 1st
2015. For every one of the resulting 257 graphs, we calculate
the PagerRank value of every package present at that point
in time and assign the npm rank thereupon.


///////

One of the most obvious things to investigate is which packages
have historically performed best throughout the entirety of 
\code{npm's} existence. To determine overall package popularity,
we use the geometric mean \code{npm} rank of a package over the full 
window of analysis, and order them from lowest to highest (i.e,
highly ranked to lowly ranked). Geometric mean is used in this instance
instead of arithmetic mean in order to limit the effect of outliers \cite{Wittern:2016}.
With popularity calculated in this manner, Figure \ref{topFive} presents 
the top five \code{npm} packages of all time.

The first thing to notice about these five packages is that the rankings
have changed since the time of the original paper. Gone are the packages
\code{uglify-js} and \code{coffee-script}, and newcomers \code{tape} and \{mkdirp}
have appeared. Additionally, though the package \code{should} remains on the list,
it has fallen from the #2 to the #4 position. 

Four of the five current champions are testing utilities, with
\code{mkdirp} as the odd one out, instead providing the ability to dynamically
create directories from \code{node.js}. Curiously, the testing packages
are essentially all direct competitors of one another, providing a powerful 
demonstration of the widespread importance of testing utilities as well as
the ability for the \code{npm} software ecosystem to support multiple core packages with
similar, yet distinct functionally.

While these packages represent the most consistently popular
members of \code{npm}, we also evaluate the most popular packages
on a yearly basis. Figure \ref{ranksByYear} presents the top five packages
for each individual year from 2011 to 2019. As noted in the original paper,
the top packages per year are relatively stable from 2013 on \cite{Wittern:2016}.
One notable exception to this rule is the 2016 rise in popularity of \code{eslint},
a tool for improving the quality of \code{JavaScript} code\footnote{https://www.npmjs.com/package/eslint}.





4.3.1 Identifying Top Packages
An immediate question to answer is which packages perform the 
best over the whole existence of npm. One way to
answer this question is, as illustrated in Figure 6, to 
determine the packages with the lowest mean npm rank (i.e., the
highest ranked packages). We use the geometric mean for
this purpose as it is less prone to outliers as compared to
the arithmetic mean. We limit the y axis in Figure 6 from
1 to 100 for readability.

The top packages illustrated in Figure 6 are diverse in
nature. should and nodeunit are tools for testing, uglifyjs
is used to minimize and obfuscate (client) code, coffeescript 
is a language compiling down to JavaScript, and
underscore provides a set of generic utility functions.
While the packages presented in Figure 6 stand for long
running success, a more fine grained analysis is needed to
gain insights into momentary package success. Figure 7
breaks down the 5 packages with the lowest mean npm rank
per year from 2011 to 2015. We see that, for example,
coffee-script ranks in the top 5 only in 2011 and 2012.
Other packages, like the file system utility glob or the
 evolution of testing tool tape (built on top of tap) only make
it into the top 5 in later years, i.e., 2014 and 2015. 
Interestingly though, the npm rank of packages in the top 5 remains
relatively stable, especially from 2013 on.

/////

To better understand the evolution of package popularity,
we investigate the dynamics of the top rankings over time.
While figure \ref{ranksByYear} demonstrate that package popularity
appears to be relatively stable, we can examine the number of packages
entering (and therefore exiting) the top \code{n} packages per year in
order to obtain a better view of the ecosystem as a whole.
Table \ref{numEnteringTop} depicts amount of newcomers to the top
\code{npm} ranks each year, further supporting the observation that
core \code{npm} package popularity is becoming more stable as the 
ecosystem matures.


4.3.2 Top Package Dynamics
As there seems to be little dynamics in the yearly top 5
packages as shown in Figure 7, we aim to determine how
many packages manage to enter top npm ranks over time.
Table 4 depicts the overall number of packages entering top
10, top 100, and top 250 npm ranks per year. While Table 4
indicates declining numbers of new packages entering top
ranks, it also shows that there is still a considerable amount
of them, even in 2015.

/////

One of the significant benefits of being able to determine
\code{npm} ranks over time is that it allows for the comparison
of similar packages against each other at an objective level.
Figure \ref{selectPackages} shows the npm ranks of selected 
utility packages, as chosen in the original paper \cite{Wittern:2016}.
One of these packages, \code{underscore}, is among the oldest \code{npm} 
utility packages, and the rest have been selected for being
typical alternatives to the \code{underscore} package. Some of these packages,
such as \code{lodash}, are directly or indirectly results of forks from the
\code{underscore} repository. While \code{lodash} has kept up and even surpassed
\code{underscore} in popularity, the majority of newer alternatives are unable
to consistently compete. Calculating ranks for similar groups of packages such as
this allow us to isolate notable, successful packages across the entire span of
the ecosystem's history, as well as evaluate the persistence of the most popular
core packages over time. In the example group of packages presented in Figure \ref{selectPackages},
we can observe that the package established early in the ecosystem's life-cycle
is well-positioned to maintain a significant level of popularity, while the majority of
other packages tend to eventually decline unless they provide something exceptional,
such as \code{lodash} providing API compatibility with \code{underscore}\footnote{https://lodash.com/}.


4.3.3 Comparing Popularity of Similar Packages
Another capability arising from being able to determine
npm ranks over time is to compare selected packages against
each other. Figure 8 shows the npm ranks of selected utility
packages over time. These utility packages typically provide
a broad set of capabilities like improving convenience
in dealing with data types like objects, arrays, or strings.
As Figure 8 shows, one package in particular, underscore,
has been introduced early in npm’s history5. Since its release,
underscore held a top npm rank. Nonetheless, multiple competitors
have entered npm since then, some of which
directly position themselves as alternatives to underscore.
For example, lodash evolved from a fork from the under score project and kept API compatibility6, and lazy.js
proclaims to be “[...] similar to underscore and lodash,
[...]”7. The selection of presented utility packages is based
on a web search for underscore competitors. While various underscore competitors have entered npm throughout
its history, most of their npm ranks are on a declining trajectory since 2014, even if they exhibited growth before. The
one exception is lodash, which has gradually risen in npm
rank since its introduction and was able to surpass underscore for good in May 2015 according to our data.
Takeaways. Calculating npm ranks (i.e., PageRanks) over
time allows to identify well-performing packages across the
life-cycle of a software ecosystem. They can also be used
to determine how dynamic or static the ranks of the most
popular packages are. For npm, we find that, while decreasing, there is still considerable amount of change in the top
ranks. Nonetheless, comparing functionally similar packages indicates that high popularity for some packages may
be long lasting. In our example, we find that most utility
libraries are declining as compared to the dominant underscore, except competitor lodash which positioned itself well
by providing API compatibility.

//////


In this paper, we take a second look at the \code{npm} ecosystem,
replicating and extending the results of previous research by 
Wittern, Suter and Rajagopalan \cite{Wittern:2016}. Though
we observe that while the growth of \code{npm} has slowed down, the ecosystem
continues to thrive, demonstrating signs of maturity rather than decline.

Contrary to the trend observed in the original paper, there appears to be
some effort to reduce the number of inter-package dependencies, and therefore the risks
associated with complex dependency trees. The core set of packages upon which
multiple other projects rely on has remained relatively constant in size, and
demonstrates a trend towards even further concentration. Accordingly, the set of packages
most depended on in the \code{npm} ecosystem is also trending towards stability, with
fewer and fewer packages entering the top ranks each year. 

Our results regarding relationships between popularity metrics support the discoveries of the
original paper, further reinforcing the theory that packages can be generally divided into the categories
of end user and core utility packages, and improving our understanding of how package popularity evolves.
Ultimately, our second evaluation of the \code{JavaScript} package environment can help developers evaluate
the state of the \code{npm} ecosystem, and continue to make informed decisions when selecting frameworks
to use in their applications.



In this paper, we conducted an analysis of the npm ecosystem, one of the largest software ecosystems encompassing
application frameworks, libraries, and utilities used in both
server-side Node.js and browser-side JavaScript applications.
We find npm to be a striving ecosystem with ongoing and
even accelerating growth of packages and increasing dependencies between them.
 Our findings regarding the differences in popularity measures can be used to improve the
search and recommendation systems targeting npm, as well
as help developers to make informed decisions when choosing packages 
for use in their applications. Finally, our assessment of version numbers indicates different conventions
embraced by developers, despite the prescribed usage of semantic versioning, and our assessment of version adoption
shows that flexible version queries can lead to significant
immediate adoption ratios.

