


Software ecosystems consist of software projects that are
developed and evolve together in a shared environment [13].
Research on such ecosystems only recently emerged within
software engineering [15]. It addresses, among other things,
the analysis of the characteristics and evolution of software
ecosystems, which some researchers consider to be a central
subject in this field of research [26]

Software ecosystems are environments that form as projects evolve in parallel,
becoming interconnected as contexts and dependencies span companies and communities [13]. 
Research on these systems has increased rapidly in the recent past [new], investigating
their characteristics and behaviour as they develop [14]. Understanding how software
ecosystems form and change is valuable from both a software as well as a business standpoint [15],
and is important for informing developers how technologies are used over time [26]. 
An understanding of software ecosystems can inform decisions on when to adopt frameworks and how long
to support them, as well as provide insight into how changes to software propagate throughout the community [wittern].




To that regard, some
software ecosystems have been scientifically assessed, including the Maven [23], Apache [2], Gentoo [4], Ruby [11], and
R [8] ecosystems. Nonetheless, a systematic literature study
from 2013 found that research regarding real-world software
ecosystems is lacking [14].

[n/a]


The study of characteristics and the evolution of software
ecosystems is an end in itself, allowing to understand how
certain technologies spread or why others fail. In addition,
this research can also inform the design of new ecosystems
and associated tooling, including technical as well as social
aspects [26]. Furthermore, as software projects are seldom
created in isolation, studying individual software projects
often requires studying the ecosystem around them [3].


Additionally, determining the characteristics of software ecosystems 
can help clarify why some frameworks flourish while others fail, and guide 
developers in the creation of new tools\cite{serebrenik}. Furthermore, 
because software projects are overwhelmingly a collaborative effort, a complete
understanding of a single project often requires knowledge of the ecosystem surrounding them[blnko].



The node package manager (npm) combines a set of open
source tools that developers use to describe their JavaScript
packages, and specifically Node.js packages. These tools include, for example, a command line interface to create and
maintain package.json files, which declare, among other
things, the name, description, version, and dependencies of
a package. npm furthermore features a registry that developers can use to publish their packages, making them available
for others to use. Packages within npm may depend on each
other, and software projects outside of npm, for example applications, may specify dependencies to packages hosted on
npm. 

npm provides a set of open source tools that allow developers to 
describe packages for Node.js, an asynchronous JavaScript runtime environment 
designed for network applications \footnote{https://nodejs.org/en/about/}.
The services provided by npm include a command line interface for maintaining 
package.json files, the primary method for describing package metadata such as the name,
description, version, and dependencies of a given package. npm also allows 
developers to publish their packages to a public registry, permitting anyone 
to download and use their software. Packages hosted on npm will often depend on other npm packages,
creating an elaborate JavaScript ecosystem of interdependence.

Since its creation in 2009, npm has grown rapidly to now
feature over 230, 000 packages (as of January 28th, 2016).
npm provides a complete set of various historic data points
on the packages in the ecosystem. This data thus not only
provides insights into the current state of the ecosystem, but
also into how the ecosystem evolved over time. The diversity
of available data points furthermore allows us to assess the
ecosystem from multiple perspectives and to compare these
perspectives. Understanding npm provides valuable insights
into the rapid growth JavaScript and Node.js experienced
within the last years. It also helps to understand how individual packages rose in popularity, prevailed, and sometimes
were eventually replaced or disregarded.


///// ecosystem evolution

Created in 2009, \code{npm} has grown
rapidly in popularity and scope over the last ten years, and 
as of the original paper showed no signs of slowing down \cite{Wittern:2016}.
We investigate the state of the \code{npm} ecosystem
since September 1\super{st} 2015, and look for any signs of deterioration in 
the health of the ecosystem. Periods of stagnating growth would suggest
that developer interest is waning, while steady activity would 
indicate that the ecosystem as a whole is healthy and will continue to
evolve. To search for these potential indicators in the \code{npm} package environment,
we investigate the number of packages created and updated over time, as well
as system-wide trends of dependencies within packages. In figure 1 
[INSERT DATA COMMENTARY HERE]. Figure 2 [MORE DATA COMMENTARY].



The npm package repository was created in 2009. Over the
last six years, the software repository has evolved rapidly
and currently hosts over 230, 000 packages. We investigate
the evolution of this ecosystem over this period and look for
signs of stagnation. Stagnation indicates that the community 
involvement has slowed down, while continued signs of
growth and activity indicates that there is increasing adoption 
and contributions by the developer community. To
characterize growth and activity, we look at the number of
new packages added to the repository over the observation
period, the number of packages that were updated, and the
dependencies among packages.

In Figure 1, we show the growth in number of packages
that are being added to npm every month, and the number of
packages that are being updated per month. Broadly speaking, 
we find that the developer community around Node.js
has been steadily increasing over the last 6 years, as evidenced 
by the increasing number of packages being created every month 
in the npm repository. In addition, the
community is also quite active in terms of maintaining the
packages hosted in the repository, as indicated by the twofold 
increase in the number of packages being updated every
month.


We then compare the growth in the total number of packages over 
time with the dependencies, i.e., relationships, between packages. 
The dependency measure per package is
the sum of number of its dependencies mentioned in dependencies 
and devDependencies fields in the package.json
file corresponding to each package. As shown in Figure 2,
not only is the npm ecosystem growing superlinearly in terms
of the number of packages and dependencies, the relationship 
among packages is also growing at a much higher rate,
indicating that the packages are depending more and more
on each other. We confirm our observation by plotting the
average number of dependencies per package (red line) in
the same figure. On average, a package in npm had approximately
 4-6 dependencies on other packages in late 2015,
compared to just one dependency in early 2011.

To further understand the dependency relationship between 
packages, we constructed a directed graph, where
packages form the vertices and directed edges between vertices
 represent the dependency between the two packages.
The out degree of a vertex indicates the number of dependencies
 of the package represented by the vertex, while the
in degree represents the number of packages that depend on
the given package.
Figure 3 shows the distribution of the out degrees across
all packages over time. The number of packages having one
or more dependencies has increased from 23.4% in January
2011 to 81.3% by end of August 2015. Specifically, there has
been a steady increase in the number of packages with 6 or
more dependencies, starting with 0% in January 2011 and
reaching 32.5% by end of August 2015.

To better visualize the status of inter-package dependencies, we constructed
a directed dependency graph using dependants as out-degrees and
dependencies as in-degrees. Based on this dependency graph, Figure 3
displays the percentage of packages with various amounts of dependencies. 
[MIGHT NEED TO CHANGE BASED ON DATA: While the average number of dependencies 
of packages continues to increase, the percentage of packages with zero 
to three dependencies has actually increased since the end of the original paper's
reporting period \cite{Wittern:2016}. This suggests some changes to developer 
behaviour, either deliberately as programmers seek to avoid the perils of 
complicated dependency trees \cite{Kikas}, or as a natural result of the ever-changing
ways in which JavaScript is used for project development.



Given the increasing number of external dependencies per
package, we tried to understand whether such dependencies 
were spread equally across all packages or if they were
confined to just a limited set of packages. To answer this
question, we look at Figure 4, showing the distribution of
in degrees across all packages. At the end of August 2015,
72.5% of packages had no incoming dependency, i.e., they
had no dependent packages, while only 4.9% of packages had
6 or more dependants, up from 1.1% in January 2011. Such
uneven distribution of package dependencies has been previously 
observed in other software ecosystems as well [18].

In addition to the number of external dependencies per package, 
we investigate how packages support dependants. The original paper 
discovered that the majority of in degrees are concentrated among a core 
minority of packages, with the majority of packages having no dependants,
a discovery that has also been observed in other software ecosystems such
as Linux and MySQL \cite{Myers:2003}. In our updated data, we discover 
that not only have these aspects held true, but the concentration of 
dependencies has actually increased proportionately, with [NUMBER]% of packages
having zero dependants, up from [NUMBER]% in 2015. Meanwhile, only %[NUM] of packages
had 6 or more dependants, down from %[NUM] as of September 1\textsuperscript{st} 2015.






In Section 4, we investigate the ranking of packages within
and outside the ecosystem to shed light on the dynamics of
package popularity in the npm ecosystem.
Takeaways. We find that the npm ecosystem continues to
grow in terms of the number of packages it hosts. At the
same time, the number of packages being updated monthly
has also grown two-fold, indicating that the developer 
community remains quite active in terms of maintaining their
packages. Looking at the relationships between packages,
we find there is an increasing amount of dependency across
packages, with 81.3% of them depending on at least one
package and 32.5% of them depending on 6 or more packages.
 However, the proportion of packages that are being
depended upon is only 27.5% of overall packages in npm, 
indicating that package dependencies exhibit a power law 
distribution, as has been observed by prior research on 
software related artifacts and ecosystems [12, 18].

[todo ^^^^]

In section \ref{}, we revisit the popularity measures
investigated in the original paper \cite{Wittern:2016} to discover
changes in the relationships between package rankings
both inside and outside of the \code{npm} ecosystem,
gaining insight into the dynamics of \code{npm} package popularity.

\textbf{Takeaways.} We find that while the \code{npm} ecosystem
continues to grow, the rate of growth is no longer superlinear, 
a possible sign of the ecosystem beginning to reach some form of maturity.
In the relationships between packages, we find that though the average number
of dependencies continues to grow, there has been a recent decline in the
rate of this growth. Accordingly, we have found that the number of packages with
zero dependencies has increased from 28.7% in September 2015 to [DATA REQUIRED]%
as of April 2019. The percentage of packages that are depended on has
also declined, albeit still exhibiting a power law relationship as observed
in prior software ecosystem research \cite{Witterm:2016}





Empirical analysis of software ecosystems is an important
aspect of software ecosystem research as a whole [26]. 
Correspondingly, related work focuses on specific aspects like
visualization [13], depicting ecosystem maturity [1], or how
to aggregate software quality metrics [17].
Some works empirically analyze software ecosystems that
evolve around a specific programming languages, as we did
for npm. Raemaekers et al. present a crawled dataset containing 
basic metrics, dependencies, and changes with some
aggregate statistics about Maven, a popular package manager
for Java [23]. Another work runs software to identify bugs in
source code of libraries shared in the same ecosystem [16]. In
contrast to these works, our study of the npm ecosystem focuses 
on the ecosystem evolution, popularity measures, and
package versioning. An analysis of the statistical computing 
project R [8] finds a super-linear growth in packages as
we report in Section 3. In addition, the study focuses on
characterizing contributions to user-contributed versus core
packages. We refrain from running a similar analysis as npm
does not differentiate packages explicitly in such a way, 
although we did identify different types of packages based on
our analysis of popularity measures (see Section 4.2). In [11],
the authors present results of a quantitative study of the
Ruby ecosystem. The paper presents a graph visualization
of the whole ecosystem as well as some descriptive statistics
and histograms about selected characteristics of packages,
including downloads and package size. In contrast to our
work, the dataset is much smaller, having only around 10K
gem nodes and 13.1K dependencies. Furthermore, the paper
does not go into the dynamics of the ecosystem, considering
instead a single point in time. We did not find any published
empirical analyses of the npm ecosystem.
Some works have studied the evolution of versions and corresponding 
change of software projects. For example, in a recent empirical 
study [5] regarding two ecosystems (including
npm) the authors find that developers struggle with changing 
versions as they might break dependent code. Similar
assessments on the effects of changes have been made regarding 
the Apache ecosystem [2] or the Maven ecosystem [24].
In contrast to these works, we assess versions in npm from a
black-box perspective: we do not assess how version changes
are reflected in the implementation of individual packages,
but focus on the occurrence of version numbers and how
they are adopted by application developers.
Finally, npm has occasionally been analyzed out of the context 
of peer-reviewed venues. npm packages pagerank provides a 
keyword-based search for packages, and presents the
results as recommendations based on their PageRank [21].
While we also consider the PageRank as a possible popularity 
measure, we have shown that this metric may not be
adequate for packages most useful to application developers
(Section 4.2). The project npm by numbers analyses a
snapshot of the npm ecosystem from September 2015 and
presents various statistics on it, including the distribution
of version numbers and releases of packages and the 
dependencies between packages [25]. In contrast to our work, npm
by numbers considers only a single point in time, whereas
we focus on the evolution of the ecosystem, and provides no
insight derived from client applications.